use orbtk::prelude::*;

use crossbeam::crossbeam_channel::{Sender};
type FutureSender = Option<Sender<impl Future>>;
use std::sync::{Arc, Mutex};                                                                               


widget!(MainView<MainViewState> {
    text: String16
});

fn main() {
    // use tokio runtime since it works for both HN and twitter
    let tokio_rt = tokio::runtime::Runtime::new()
        .expect("Failed to get tokio runtime")
        ;

    // before wrapping the runtime, spawn a thread for the twitter custom feed future to run
    let (tx, rx) = crossbeam::channel::bounded(0);

    // Spawn a future onto the runtime
    let r2 = rx.clone();
    rt.spawn(async move {
        println!("\t\t tw custom worker thread: started");
        match r2.recv() {
          Ok(f) => {
            println!("tw custom worker thread: received future");
            f.await;
          },
          Err(e) => {
            println!("tw custom worker thread error: {}", e);
          }
        }
    });

    // wrap the runtime for later use
    let tokio_rt = Arc::new(Mutex::new(tokio_rt));


    let future_sender: FutureSender = Some(tx);


      Application::new()
        .window(move |ctx| {
let mut main_view = MainView::create();
			main_view.future_sender = Some(PropertySrouce::Value(future_sender.clone())); 

            Window::new()
                .title("OrbTk - minimal example")
                .position((100.0, 100.0))
                .size(300.0, 400.0)
                .child(TextBlock::new().text("OrbTk").build(ctx))
                .build(ctx)
main_view.child().build(ctx)
        })
        .run();
}
